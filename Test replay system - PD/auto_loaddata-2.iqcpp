{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor LM = motor(PORT12, true);\nmotor RM = motor(PORT6, false);\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n#include <string>\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nint left_motor_degree = 0, left_motor_vel = 0, \n    right_motor_degree = 0, right_motor_vel = 0;\ndouble prev_robot_heading = 0.0, robot_heading = 0.0;\ndouble previous_time = 0.0, current_time = 0.0;\n\nint main() {\n  // Begin project code\n  int i = 0;\n  int j = 1;\n  LM.setPosition(0, degrees); RM.setPosition(0, degrees);\n  while(Brain.SDcard.exists((\"data\"+std::to_string(j)+\".txt\").c_str())) {\n    char driver_input[300];\n    Brain.SDcard.loadfile((\"data\"+std::to_string(j)+\".txt\").c_str(), (uint8_t*)driver_input, sizeof(driver_input)); \n    printf(\"%s\\n\", (\"data\"+std::to_string(j)+\".txt\").c_str());\n    printf(\"%s\\n\", driver_input);\n    j++;  i = 0;\n    LM.spin(forward); RM.spin(forward);\n    while (driver_input[i] != '*'){\n      //Get values for \n      current_time = Brain.Timer.value(); //\n      robot_heading = BrainInertial.rotation(degrees);\n\n      int mulL = 1, mulR = 1, mulY = 1, mulX = 1;\n      double mulT = 1.0;\n      std::string L = \"\", R = \"\", Y = \"\", X = \"\", Theta = \"\";\n      while(driver_input[i] != '#'){\n        if(driver_input[i] == '-'){\n          mulL = -1;\n          i+=1;\n          continue;\n        }\n        L += driver_input[i];\n        i+=1;\n      }\n      i+=1;\n      while(driver_input[i] != '#'){\n        if(driver_input[i] == '-'){\n          i+=1;\n          mulR = -1;\n          continue;\n        }\n        R += driver_input[i];\n        i+=1;\n      }\n      i+=1;\n      while(driver_input[i] != '#'){\n        if(driver_input[i] == '-'){\n          i+=1;\n          mulY = -1;\n          continue;\n        }\n        Y += driver_input[i];\n        i+=1;\n      }\n      i+=1;\n      while(driver_input[i] != '#'){\n        if(driver_input[i] == '-'){\n          i+=1;\n          mulX = -1;\n          continue;\n        }\n        X += driver_input[i];\n        i+=1;\n      }\n      i+=1;\n      while(driver_input[i] != '#'){\n        if(driver_input[i] == '-'){\n          i+=1;\n          mulT = -1.0;\n          continue;\n        }\n        Theta += driver_input[i];\n        i+=1;\n      }\n      i+=1;\n      left_motor_degree = stoi(L)*mulL, right_motor_degree = stoi(R)*mulR,\n      left_motor_vel = stoi(Y)*mulY + stoi(X)*mulX, right_motor_vel = stoi(Y)*mulY - stoi(X)*mulX;\n      double target_robot_heading = stod(Theta)*mulT;\n\n      //Calculate PID rotation\n      double Kpr = 0.8, Kdr = 0.03; //PD value for rotation\n      double Kpm, Kdm;  //PD value for movement\n      double output_r = (target_robot_heading-robot_heading)*Kpr + (robot_heading-prev_robot_heading)*(current_time-previous_time)*Kdr;\n      //Output\n      LM.setVelocity(left_motor_vel, percent);\n      RM.setVelocity(right_motor_vel, percent);\n\n      wait(50, msec);\n      previous_time = current_time;\n      prev_robot_heading = robot_heading;\n    }\n  }\n  printf(\"finished data file\\n\");\n}\n","textLanguage":"cpp","rconfig":[{"port":[12],"name":"LM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"RM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":4,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}