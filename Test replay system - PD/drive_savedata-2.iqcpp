{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\ncontroller Controller = controller();\nmotor LM = motor(PORT12, true);\nmotor RM = motor(PORT6, false);\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// Include the IQ Library\n#include \"vex.h\"\n#include <string>\n#include <fstream>\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n\nint Brain_precision = 0, Console_precision = 0;\n\nfloat myVariable;\n\n// Used to find the format string for printing numbers with the\n// desired number of decimal places\nconst char* printToConsole_numberFormat() {\n  // look at the current precision setting to find the format string\n  switch(Console_precision){\n    case 0:  return \"%.0f\"; // 0 decimal places (1)\n    case 1:  return \"%.1f\"; // 1 decimal place  (0.1)\n    case 2:  return \"%.2f\"; // 2 decimal places (0.01)\n    case 3:  return \"%.3f\"; // 3 decimal places (0.001)\n    default: return \"%f\"; // use the print system default for everthing else\n  }\n}\nstd::string driver_input = \"\", temp = \"\";\nint i = 1;\n// \"when started\" hat block\n\nvoid writetofile(){\n  const char * _input = temp.c_str();\n  printf(\"%s\\n\", _input);\n  const char * fileName = (\"data\" + std::to_string(i) + \".txt\").c_str();\n  Brain.SDcard.savefile(fileName, (uint8_t *)_input, temp.size());\n  i++;\n}\n\nvoid savedata(){\n\n  //Reset input file\n  while(Brain.SDcard.exists((\"data\"+std::to_string(i)+\".txt\").c_str())) {\n    char empty_string[300] = \"*\";\n    Brain.SDcard.savefile((\"data\"+std::to_string(i)+\".txt\").c_str(), (uint8_t *)empty_string, sizeof(empty_string));\n    i++;\n  }\n  i = 1;\n  while(1) {\n    int L = LM.position(degrees), Y = Controller.AxisA.position(),\n        R = RM.position(degrees), X = Controller.AxisC.position();\n    float Theta = BrainInertial.rotation(degrees);\n    driver_input += std::to_string(L) + '#' + std::to_string(R)+ '#'\n                  + std::to_string(Y) + '#' + std::to_string(X) + '#'\n                  + std::to_string(Theta) + '#';\n    if(driver_input.size() >= 200) {\n      driver_input += '*';\n      temp = driver_input;\n      thread write = thread(writetofile);\n      driver_input = \"\";\n    }\n    wait(100, msec);\n  }\n}\n\nvoid Drive(){\n  BrainInertial.calibrate();\n  wait(2.5,seconds);\n  Brain.playSound(alarm);\n  BrainInertial.setHeading(0, degrees);\n  LM.spin(forward);\n  RM.spin(forward);\n  LM.setPosition(0, degrees);\n  RM.setPosition(0, degrees);\n  while (true){\n    int Y = Controller.AxisA.position(), X = Controller.AxisC.position();\n    LM.setVelocity(Y+X, percent);\n    RM.setVelocity(Y-X, percent);\n    wait(100, msec);\n  }\n}\n\nint main() {\n  thread drivemode = thread(Drive);\n  savedata();\n}","textLanguage":"cpp","rconfig":[{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[12],"name":"LM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"RM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}